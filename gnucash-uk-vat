#!/usr/bin/env python3

import sys
import argparse
import json
from datetime import datetime, timedelta
from tabulate import tabulate
import uuid
import getpass
import socket
import os
import model

# Local Python modules
import hmrc
import accounts

# Command-line argument parser
parser = argparse.ArgumentParser(description="Gnucash to HMRC VAT API")
parser.add_argument('--config', '-c',
		    default='config.json',
                    help='Configuration file')
parser.add_argument('--auth', '-a',
		    default='auth.json',
                    help='File to store auth credentials')
parser.add_argument('--init-config', action='store_true',
                    help='Initialise configuration')
parser.add_argument('--authenticate', action='store_true',
                    help='Perform authentication process')
parser.add_argument('--show-open-obligations', action='store_true',
                    help='Show VAT obligations')
parser.add_argument('--show-obligations', action='store_true',
                    help='Show all VAT obligations in time period')
parser.add_argument('--start',
                    default=356,
                    help='Start period as days back from today')
parser.add_argument('--end',
                    default=0,
                    help='End of period as days back from today')
parser.add_argument('--show-account-detail', action='store_true',
                    help='Show account detail for VAT obligations')
parser.add_argument('--show-account-summary', action='store_true',
                    help='Show account summary for VAT obligations')
parser.add_argument('--show-vat-return', action='store_true',
                    help='Show VAT return for period')
parser.add_argument('--period', default=None,
                    help='VAT period key')
parser.add_argument('--submit-vat-return', action='store_true',
                    help='Submit VAT return for period')
parser.add_argument('--post-vat-bill', action='store_true',
                    help='Post a VAT bill to accounts for period')
parser.add_argument('--show-liabilities', action='store_true',
                    help='Show VAT liabilities')
parser.add_argument('--show-payments', action='store_true',
                    help='Show VAT payments')

# Parse arguments
args = parser.parse_args(sys.argv[1:])

# Configuration object, loads configuration from a JSON file, and then
# supports path navigate with config.get("part1.part2.part3")
class Config:
    def __init__(self, file="config.json"):
        self.config = json.loads(open(file).read())
    def get(self, key):
        cfg = self.config
        for v in key.split("."):
            cfg = cfg[v]
        return cfg

# Authentication object.  Supports loading from file as JSON, writing back
# updated auth, and refresh
class Auth:
    # Constructor, load auth from file
    def __init__(self, file="auth.json"):
        self.file = file
        try:
            self.auth = json.loads(open(file).read())
        except:
            self.auth = {}

    # Get an authentication data value
    def get(self, key):
        cfg = self.auth
        for v in key.split("."):
            cfg = cfg[v]
        return cfg

    # Write back to file
    def write(self):
        with open(self.file, "w") as auth_file:
            auth_file.write(json.dumps(self.auth, indent=4))

    # Refresh expired token using the refresh token, and write new
    # creds back to the auth file.  svc=API service
    def refresh(self, svc):
        self.auth = svc.refresh_token(self.auth["refresh_token"])
        self.write()

    # If token has expired, refresh.
    def maybe_refresh(self, svc):
        if "expires" not in self.auth:
            raise RuntimeError("No token expiry.  Have you authenticated?")
        expires = datetime.fromisoformat(self.auth["expires"])
        if  datetime.utcnow() > expires:
            self.refresh(svc)

# Initialise configuration file with some (mainly) static values.  Also,
# collate personal information for the Fraud API.
def initialise_config(config_file):

    # This gets hold of the MAC address, which the uuid module knows.
    # FIXME: Hacky.
    try:
        mac = uuid.getnode()
        mac = [
            '{:02x}'.format((mac >> ele) & 0xff)
            for ele in range(0,8*6,8)
        ][::-1]
        mac = ':'.join(mac)
    except:
        # Fallback.
        mac = '00:00:00:00:00:00'

    # Operating system information
    uname = os.uname()
    ua = "%s/%s (%s/%s)" % (
        uname.sysname, uname.release, "Python", uname.machine
    )

    config = {
        "accounts": {
	    "file": "accounts/accounts.gnucash",
            "vatDueSales": "VAT:Output:Sales",
            "vatDueAcquisitions": "VAT:Output:EU",
            "totalVatDue": "VAT:Output",
            "vatReclaimedCurrPeriod": "VAT:Input",
            "netVatDue": "VAT",
            "totalValueSalesExVAT":
            "Assets:Capital Equipment:EU Reverse VAT Purchase",
            "totalValuePurchasesExVAT": "Assets:Computer Equipment",
            "totalValueGoodsSuppliedExVAT": "Income:Sales:EU:Goods",
            "totalAcquisitionsExVAT": "Expenses:VAT Purchases:EU Reverse VAT",
            "liabilities": "VAT:Liabilities",
            "bills": "Accounts Payable",
            "vendor": {
                "id": "hmrc-vat",
                "currency": "GBP",
                "name": "HM Revenue and Customs - VAT",
                "address": [
                    "123 St Vincent Street",
                    "Glasgow City",
                    "Glasgow G2 5EA",
                    "UK"
                ],
                "phone": "0300 200 3700"
            }
        },
        "application": {
            "profile": "test",
            "client-id": "<CLIENTID>",
            "client-secret": "<CLIENTSECRET>"
        },
        "identity": {
            "vrn": "<VRN>",
            "device": str(uuid.uuid1()),
            "user": getpass.getuser(),
            "hostname": socket.gethostbyname(socket.gethostname()),
            "mac-address": mac,
            "user-agent": ua
        }
    }

    with open(config_file, "w") as cfg_file:
        cfg_file.write(json.dumps(config, indent=4))

    sys.stderr.write("Wrote %s.\n" % config_file)

# Perform authentication operation
def authenticate(h, auth):
    code = h.get_code()
    sys.stderr.write("Got one-time code.\n")
    h.get_auth(code)
    sys.stderr.write("Got authentication key.\n")
    auth.write()
    sys.stderr.write("Wrote %s.\n" % auth.file)

# Show obligations with the O state
def show_open_obligations(h, config):

    obs = h.get_open_obligations(config.get("identity.vrn"))

    tbl = [
        [v.periodKey, v.start, v.end, v.due, v.status]
        for v in obs
    ]

    print(tabulate(tbl, ["Period", "Start", "End", "Due", "Status"],
                   tablefmt="pretty"))

# Show obligations in a time period
def show_obligations(start, end, h, config):

    obs = h.get_obligations(config.get("identity.vrn"), start, end)

    tbl = [
        [v.periodKey, v.start, v.end, v.due, v.received, v.status]
        for v in obs
    ]

    print(tabulate(tbl,
                   ["Period", "Start", "End", "Due", "Received", "Status"],
                   tablefmt="pretty"))

# Submit a VAT return
def submit_vat_return(period, h, config):

    # We need start/end information, but only have a period key first.
    # Load the obligations to get the mapping
    obs = h.get_open_obligations(config.get("identity.vrn"))

    # Iterate over obligations to find the period
    obl = None
    for v in obs:
        if v.periodKey == period:
            obl = v

    # Not found
    if obl == None:
        raise RuntimeError("Period '%s' not in obligations" % period)

    # Get start/end date
    start = obl.start
    end = obl.end

    # Open GnuCash accounts, and get VAT records for the period
    accts = accounts.Accounts(config)
    vals = accts.get_vat(start, end)

    # Build base of the VAT return
    rtn = model.Return()
    rtn.periodKey = period
    rtn.finalised = True

    # Add VAT values
    for k in range(0, 9):
        valueName = model.vat_fields[k]
        setattr(rtn, valueName, vals[valueName]["total"])

    # Dump output.  Too late to fix anything anyway.
    # FIXME: Are you sure? etc.
    sys.stdout.write(rtn.to_string())

    # Call the API
    resp = h.submit_vat_return(config.get("identity.vrn"), rtn)

    # Dump out the response
    print()
    print("Submitted.")
    if "processingDate" in resp:
        print("%-30s: %s" % ("Processing date", resp["processingDate"]))
    if "paymentIndicator" in resp:
        print("%-30s: %s" % ("Payment indicator", resp["paymentIndicator"]))
    if "formBundleNumber" in resp:
        print("%-30s: %s" % ("Form bundle", resp["formBundleNumber"]))
    if "chargeRefNumber" in resp:
        print("%-30s: %s" % ("Charge ref", resp["chargeRefNumber"]))

# Submit a VAT return
def post_vat_bill(start, end, period, h, config):

    # We need start/end information, but only have a period key first.
    # Load the obligations to get the mapping
    obs = h.get_obligations(config.get("identity.vrn"), start, end)

    # Iterate over obligations to find the period
    obl = None
    for v in obs:
        if v.periodKey == period:
            obl = v

    # Not found
    if obl == None:
        raise RuntimeError("Period '%s' not in obligations" % period)

    # Get start/end date
    start = obl.start
    end = obl.end
    print(start, end)

    # Open GnuCash accounts, and get VAT records for the period
    accts = accounts.Accounts(config)
    vals = accts.get_vat(start, end)

    # Build base of the VAT return
    rtn = model.Return()
    rtn.periodKey = period
    rtn.finalised = True

    # Add VAT values
    for k in range(0, 9):
        valueName = model.vat_fields[k]
        setattr(rtn, valueName, vals[valueName]["total"])

    # Dump output.  Too late to fix anything anyway.
    # FIXME: Are you sure? etc.
    sys.stdout.write(rtn.to_string())

    # FIXME: How to work out due date?  Online says 1 cal month plus 7 days
    # from end of accounting period
    accts.post_vat_bill(
        period,
        datetime.utcnow().date(),
        end + timedelta(days=28) + timedelta(days=7),
        rtn,
        rtn.to_string(show_key=True),
        "VAT payment for period " + period
    )

# Show GnuCash information relating to open VAT obligations
def show_account_data(h, config, detail=False):

    # Get open obligations
    obs = h.get_open_obligations(config.get("identity.vrn"))

    # Get accounts
    accts = accounts.Accounts(config)

    # Iterate over obligations
    for v in obs:

        # Write out obligation header
        print("Period: %-10s    Start: %-10s     End: %-10s" % (
            v.periodKey, v.start, v.end
        ))
        print()

        # Get VAT values for this period from accounts
        vals = accts.get_vat(v.start, v.end)

        # Loop over 9 boxes (0 .. 8 in this loop)
        for k in range(0, 9):

            # Get the name of the VAT value
            valueName = model.vat_fields[k]

            valueDesc = model.vat_descriptions.get(valueName, valueName)

            # Output the value
            print("    %s: %.2f" % (valueDesc, vals[valueName]["total"]))

            # In detail mode, transactions are shown, otherwise skip that part
            if not detail: continue

            print()

            # Dump out all contributing transactions
            if len(vals[valueName]["splits"]) > 0:

                # Construct a transaction table
                tbl = []

                # Add transactions to table
                for w in vals[valueName]["splits"]:
                    tbl.append([
                        w["date"], "%.2f" % w["amount"], w["description"][0:60]
                    ])

                # Create table
                tbl = tabulate(tbl, tablefmt="pretty",
                               colalign=("left", "right","left"))

                # Indent table by 8 characters
                tbl = "        " + tbl.replace("\n", "\n        ")
                print(tbl)

                print()

# Dump out a VAT return
def show_vat_return(h, config, period):

    # Fetch VAT return data
    rtn = h.get_vat_return(config.get("identity.vrn"), period)
    sys.stdout.write(rtn.to_string())

# Show liabilities
def show_liabilities(start, end, h, config):

    # Fetch values from liabilities endpoint
    rtn = h.get_vat_liabilities(config.get("identity.vrn"), start, end)

    # Initialise empty table
    tbl = []

    # Iterate over liabilities, build table
    for v in rtn:
        ent = []
        ent.append(v.end)
        ent.append(v.typ[0:20])
        ent.append(v.original)
        ent.append(v.outstanding)
        ent.append(v.due)
        tbl.append(ent)

    # Dump out table
    print(tabulate(tbl, ["Period End", "Type", "Amount", "Outstanding", "Due"],
                   tablefmt="pretty"))

def show_payments(start, end, h, config):

    # Fetch values from payments endpoint
    rtn = h.get_vat_payments(config.get("identity.vrn"), start, end)

    # Initialise empty table
    tbl = []

    # Iterate over payments, build table
    for v in rtn:
        ent = []
        ent.append(v.amount)
        ent.append(v.received)
        tbl.append(ent)

    # Dump out table
    print(tabulate(tbl, ["Amount", "Received"],
                   tablefmt="pretty"))

# Initialise configuration operation.  This goes here as configuration
# can be initialised if no auth has been performed
if args.init_config:
    initialise_config(args.config)
    sys.exit(0)

# Initialise config and auth.  
config = Config(args.config)
auth = Auth(args.auth)

# Get profile
prof = config.get("application.profile")

# Initialise API client endpoint based on selected profile
if prof == "prod":
    h = hmrc.Vat(config, auth)
elif prof == "test":
    h = hmrc.VatTest(config, auth)
elif prof == "local":
    h = hmrc.VatLocalTest(config, auth)
else:
    sys.stderr.write("Profile '%s' is not known." % prof)

# Authentication operation goes here.
if args.authenticate:
    authenticate(h, auth)
    sys.exit(0)

# All following operations require a valid token, so refresh token if expired.
auth.maybe_refresh(h)

# Call appropriate function to implement operations
try:
    if args.show_open_obligations:
        show_open_obligations(h, config)
        sys.exit(0)
    elif args.show_obligations:
        start = datetime.utcnow() - timedelta(days=int(args.start))
        end = datetime.utcnow() - timedelta(days=int(args.end))
        show_obligations(start, end, h, config)
        sys.exit(0)
    elif args.submit_vat_return:
        submit_vat_return(args.period, h, config)
        sys.exit(0)
    elif args.post_vat_bill:
        start = datetime.utcnow() - timedelta(days=int(args.start))
        end = datetime.utcnow() - timedelta(days=int(args.end))
        post_vat_bill(start, end, args.period, h, config)
        sys.exit(0)
    elif args.show_account_detail:
        show_account_data(h, config, detail=True)
        sys.exit(0)
    elif args.show_account_summary:
        show_account_data(h, config)
        sys.exit(0)
    elif args.show_vat_return:
        show_vat_return(h, config, args.period)
        sys.exit(0)
    elif args.show_liabilities:
        start = datetime.utcnow() - timedelta(days=int(args.start))
        end = datetime.utcnow() - timedelta(days=int(args.end))
        show_liabilities(start, end, h, config)
        sys.exit(0)
    elif args.show_payments:
        start = datetime.utcnow() - timedelta(days=int(args.start))
        end = datetime.utcnow() - timedelta(days=int(args.end))
        show_payments(start, end, h, config)
        sys.exit(0)
    else:
        raise RuntimeError("No operation specified.")
except Exception as e:
    sys.stderr.write("Exception: %s\n" % e)
    sys.exit(1)
